# Linked List（連結串列）

---

## 一、什麼是 Linked List（連結串列）

- 白話解釋
  - 一串由「節點（node）」組成的資料結構
  - 每個節點用指標連到下一個節點
  - 節點在記憶體中不需要連續存放

- 用來幹嘛
  - 常常需要插入、刪除資料
  - 資料數量不固定、會動態變化

- 重要特性
  - 不靠 index 存取
  - 透過指標（next）連接節點
  - 記憶體配置較有彈性

- 跟 Array 最大差別
  - Array：靠位置（index）
  - Linked List：靠指標（next）

- 生活比喻
  - 像火車車廂
  - 每節車廂只知道「下一節在哪」

---

## 二、Node（節點）是什麼

- 白話解釋
  - Linked List 中的基本單位
  - 每個節點都是一個獨立存在的資料結構

- 裡面一定有的東西
  - data：實際存放的資料
  - next：指向下一個節點的指標

- 為什麼要這樣設計
  - 不需要連續記憶體
  - 只要知道「下一個是誰」就能串起來

- 重要特性
  - 節點之間靠指標關係維持順序
  - 節點可隨時新增或移除

- 生活比喻
  - 每個人手上拿一張紙條
  - 上面寫著「下一個人在哪」

---

## 三、Head 是什麼？為什麼重要

- 白話解釋
  - 指向整條 Linked List 第一個節點的指標

- 用來幹嘛
  - 從 head 才能開始走訪整條串列
  - 所有操作（存取、插入、刪除）都從 head 開始

- 重要特性
  - 沒有 head，就無法找到整串資料
  - head 本身不是資料節點，而是入口

- 生活比喻
  - 書籤插在第一頁
  - 沒有書籤就不知道從哪開始看

---

## 四、Linked List 的存取特性（一定會考）

- 白話解釋
  - 只能一個一個節點往後走
  - 不能像 Array 用 `list[i]` 直接存取

- 為什麼
  - 節點在記憶體中是散開的
  - 只知道「下一個節點在哪」

- 結果
  - 存取第 i 個元素需要從 head 開始走
  - 時間複雜度為 O(n)

- 重要特性
  - 不支援 Random Access
  - 屬於 Sequential Access

- 生活比喻
  - 問第 10 個人是誰
  - 一定要從第 1 個一路問下去

---

## 五、插入（Insert）操作為什麼快

- 白話解釋
  - 插入時只需要改動指標
  - 不需要搬移其他資料

- 重點情況
  - 插在開頭（head）
    - 直接改 head 指向
    - 時間複雜度 O(1)
  - 插在中間
    - 先走到目標位置 O(n)
    - 接上新節點 O(1)

- 為什麼比 Array 快
  - 不需要整排資料移動
  - 只處理少量指標變化

- 生活比喻
  - 火車中間加一節車廂
  - 拆開再接回去就好

---

## 六、刪除（Delete）操作怎麼做

- 白話解釋
  - 將「前一個節點」的 next
  - 改成指向「下一個節點」

- 關鍵角色
  - target：要刪除的節點
  - prev：target 前一個節點

- 重要特性
  - 不需要搬移其他節點
  - 只需調整指標關係

- 特殊情況一定要記
  - 刪除 head（第一個節點）
  - 刪除最後一個節點

- 生活比喻
  - 把中間的人移走
  - 前後兩個人直接牽手

---

## 七、Linked List 的三種常見變形（超常考）

### Singly Linked List（單向）

- 白話解釋
  - 每個節點只有 next 指標

- 重要特性
  - 只能往前走
  - 無法回頭

- 優點
  - 結構簡單
  - 記憶體使用較少

- 缺點
  - 無法反向搜尋

- 生活比喻
  - 單行道

---

### Doubly Linked List（雙向）

- 白話解釋
  - 每個節點有 prev 與 next

- 重要特性
  - 可以前後走
  - 刪除操作更方便

- 優點
  - 支援雙向走訪

- 缺點
  - 多一個指標
  - 記憶體消耗較大

- 生活比喻
  - 雙向道路

---

### Circular Linked List（環狀）

- 白話解釋
  - 最後一個節點會指回第一個

- 重要特性
  - 沒有真正的尾端
  - 可以無限循環走訪

- 常見用途
  - 排程系統
  - 輪播機制

- 生活比喻
  - 圓形跑道
  - 一直跑不會結束

---

## 八、Linked List vs Array（老師最愛出）

- 為什麼會有 Linked List
  - 為了解決 Array 插入、刪除慢的問題

- Array 的痛點
  - 插入、刪除需要整排資料移動
  - 時間複雜度 O(n)

- Linked List 的解法
  - 用指標重新接線
  - 插入、刪除可達 O(1)

- 什麼時候用 Linked List
  - 資料數量不固定
  - 插入、刪除非常頻繁
  - 不在乎隨機存取速度

---

## 九、時間複雜度總整理（考前背）

| 操作 | Linked List |
|----|----|
| 存取第 i 個 | O(n) |
| 搜尋 | O(n) |
| 插入（已知位置） | O(1) |
| 刪除（已知節點） | O(1) |
