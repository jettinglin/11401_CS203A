# Array（陣列）

---

## 一、什麼是 Array（陣列）

- 白話解釋
  - 一排連續的格子
  - 每個格子都能放一個資料
  - 每個格子都有編號（index，通常從 0 開始）

- 用來幹嘛
  - 當你有很多同類型資料要存
  - 且常常需要用編號直接拿資料時
  - 適合「讀取次數遠大於修改次數」的情境

- 重要特性
  - 記憶體是連續配置的
  - 可用 `array[i]` 直接存取第 i 個元素
  - 存取時間複雜度為 O(1)

- 生活比喻
  - 一排有編號的置物櫃
  - 不需要翻找，只要走到指定號碼

---

## 二、一維陣列（1D Array）

- 白話解釋
  - 一條直線排列的格子
  - 每個元素只需要一個 index

- 用來幹嘛
  - 存成績
  - 存分數
  - 存數字清單或資料序列

- 重要特性
  - index 連續遞增
  - 記憶體中也是連續擺放

- 生活比喻
  - 一整排座位
  - 每個人都有固定座位號碼

---

## 三、二維陣列（2D Array）

- 白話解釋
  - 表格結構
  - 由列（row）與欄（column）組成

- 用來幹嘛
  - 成績表
  - 棋盤
  - 矩陣運算

- 重要特性
  - 需要兩個 index 存取
  - 常見形式為 `array[row][col]`

- 生活比喻
  - Excel 表格
  - 用「第幾列、第幾欄」定位資料

---

## 四、三維陣列（3D Array）

- 白話解釋
  - 好幾個二維陣列疊在一起
  - 多了一個「層」的概念

- 用來幹嘛
  - 影像資料（高、寬、顏色）
  - 影片資料（時間序列）
  - 立體或空間資料

- 重要特性
  - 使用三個 index 存取
  - 常表示為 層 / 列 / 欄

- 生活比喻
  - 一疊抽屜櫃
  - 第幾層、第幾排、第幾格

---

## 五、Static Array（靜態陣列）

- 白話解釋
  - 大小在宣告時就決定
  - 執行期間無法改變大小

- 用來幹嘛
  - 資料量一開始就能確定
  - 結構簡單、需求固定的情況

- 重要特性
  - 存取速度快
  - 不需額外記憶體管理
  - 無法動態擴充

- 生活比喻
  - 買好尺寸的便當盒
  - 裝不下就一定會溢出

---

## 六、Dynamic Array（動態陣列）

- 白話解釋
  - 使用 malloc / realloc 配置記憶體
  - 大小可以在執行期間調整

- 用來幹嘛
  - 資料數量不確定
  - 可能隨時間成長或縮小

- 重要特性
  - realloc 可能會更換記憶體位址
  - 需要手動 free，否則會造成記憶體洩漏

- 生活比喻
  - 租倉庫
  - 空間不夠就換更大的

---

## 七、Access（存取）

- 白話解釋
  - 使用 index 直接取得指定位置的資料

- 用來幹嘛
  - 快速讀取或修改特定元素
  - 常見於查詢、計算、比對

- 重要特性
  - 不需要走訪其他元素
  - 時間複雜度為 O(1)

- 生活比喻
  - 直接走到指定號碼的置物櫃

---

## 八、Insert / Delete（插入 / 刪除）

- 白話解釋
  - 在中間插入或刪除資料
  - 後面的元素需要整體搬移

- 用來幹嘛
  - 動態調整資料內容
  - 維持資料順序

- 重要特性
  - 平均時間複雜度為 O(n)
  - 因為記憶體必須保持連續

- 生活比喻
  - 排隊時有人插隊
  - 後面所有人都要移動

---

## 九、Traverse（走訪）

- 白話解釋
  - 從第一個元素走到最後一個

- 用來幹嘛
  - 印出所有資料
  - 計算總和、平均、最大值等

- 重要特性
  - 必須逐一拜訪每個元素
  - 時間複雜度為 O(n)

- 生活比喻
  - 老師一個一個點名

---

## 十、Linear Search（線性搜尋）

- 白話解釋
  - 從頭開始，一個一個比較

- 用來幹嘛
  - 在未排序的陣列中找資料
  - 結構最簡單的搜尋方式

- 重要特性
  - 最壞情況需檢查全部元素
  - 時間複雜度為 O(n)

- 生活比喻
  - 從第一頁開始翻書

---

## 十一、Binary Search（二分搜尋）

- 白話解釋
  - 每次將搜尋範圍切成一半

- 用來幹嘛
  - 在已排序的陣列中快速搜尋
  - 大量資料時效率高

- 重要特性
  - 一定要先排序
  - 時間複雜度為 O(log n)

- 生活比喻
  - 查字典直接翻中間

---

## 十二、Bubble Sort

- 白話解釋
  - 相鄰元素兩兩比較
  - 較大的值會逐步往後移動

- 用來幹嘛
  - 排序資料（教學用居多）

- 重要特性
  - 實作簡單
  - 效率最低

- 生活比喻
  - 氣泡慢慢浮到水面

---

## 十三、Selection Sort

- 白話解釋
  - 每一輪選出最小的元素

- 用來幹嘛
  - 排序資料
  - 減少交換次數

- 重要特性
  - 時間複雜度固定為 O(n²)
  - 不受資料初始順序影響

- 生活比喻
  - 每次挑全班最矮的站最前面

---

## 十四、Insertion Sort

- 白話解釋
  - 將新元素插入已排序的區段

- 用來幹嘛
  - 小型資料排序
  - 幾乎已排序資料的優化

- 重要特性
  - 資料接近排序完成時效率高
  - 最好情況為 O(n)

- 生活比喻
  - 整理撲克牌手牌

---

## 十五、Array 的優缺點

- 白話解釋
  - 陣列是一種高效但不夠彈性的結構

- 用來幹嘛
  - 判斷是否適合使用 Array
  - 與 Linked List 等結構比較

- 重要特性
  - 存取快（O(1)）
  - 插入、刪除慢（O(n)）
  - Static Array 大小固定

- 生活比喻
  - 拿東西很快
  - 但改隊形很麻煩
---

## 附錄 A：Array 維度比較表

| 維度 | 結構形式 | 需要的 index 數量 | 常見用途 | 直覺比喻 |
|----|----|----|----|----|
| 1D Array | 一條直線 | 1 個 | 成績、分數、清單 | 一整排座位 |
| 2D Array | 表格 | 2 個 | 成績表、棋盤、矩陣 | Excel 表格 |
| 3D Array | 多層表格 | 3 個 | 影像、影片、立體資料 | 抽屜櫃 |

---

## 附錄 B：Static Array vs Dynamic Array 比較表

| 項目 | Static Array | Dynamic Array |
|----|----|----|
| 大小是否可變 | 不可變 | 可變 |
| 配置時機 | 編譯期 | 執行期 |
| 記憶體管理 | 自動 | 手動（malloc / free） |
| 存取速度 | 快 | 快 |
| 使用風險 | 容易溢位 | 容易 memory leak |
| 適合情境 | 資料量固定 | 資料量不確定 |
| 生活比喻 | 固定尺寸便當盒 | 可換大小的倉庫 |

---

## 附錄 C：Array 核心操作時間複雜度表

| 操作 | 說明 | 時間複雜度 | 是否常考 |
|----|----|----|----|
| Access | 用 index 直接存取 | O(1) | 是 |
| Insert | 中間插入資料 | O(n) | 是 |
| Delete | 中間刪除資料 | O(n) | 是 |
| Traverse | 逐一走訪 | O(n) | 是 |
| Linear Search | 一個一個找 | O(n) | 是 |
| Binary Search | 對半搜尋（需排序） | O(log n) | 是 |

---

## 附錄 D：排序演算法比較表

| 排序法 | 最好情況 | 最壞情況 | 是否穩定 | 適合用途 |
|----|----|----|----|----|
| Bubble Sort | O(n) | O(n²) | 是 | 教學、理解排序概念 |
| Selection Sort | O(n²) | O(n²) | 否 | 交換成本高的情況 |
| Insertion Sort | O(n) | O(n²) | 是 | 幾乎已排序資料 |

---

## 附錄 E：什麼時候該用 Array？

| 情境 | 是否適合 | 原因 |
|----|----|----|
| 需要快速隨機存取 | 適合 | O(1) 存取 |
| 資料量固定 | 適合 | Static Array |
| 常插入 / 刪除 | 不適合 | O(n) |
| 記憶體連續性重要 | 適合 | Cache 友善 |
| 資料量高度變動 | 不適合 | realloc 成本高 |

---

